% !TEX root = ../Noctua_Machbarkeitsstudie.tex

\chapter{Technische Machbarkeit}\label{chapter:technischemachbarkeit}

\section{Variantenbildung}

\subsection{Programmiersprachen}
Die \gls{bts} kann man in jeder erdenklichen Programmiersprache schreiben, allerdings ist es wichtig daran zu denken, dass das Programm einerseits effizient arbeiten soll und deswegen hardwarenahe rechnet, und andererseits hat das Projektteam mit manchen Programmiersprachen keinerlei Erfahrung.\\
Die allgemeine Funktionalität muss das Lesen und Schreiben von Dateien sein, aber auch das algorithmische Rechnen soll effizient funktionieren. Für das Team kommen daher 3 Möglichkeiten in Frage: Eine Lösung in reinem C++, welches sehr hardwarenahe arbeitet, eine Mischung aus C\# und F\#, mit der eine parallelisierte Berechnung möglich wäre, und eine Java-Lösung, bei der das Team die größte Erfahrung mitbringt. \\
Bei der Kombination C\#/F\# agiert C\# als Handlungs- und Steuerkern und F\# als funktionale Programmiersprache, als Rechenkern und "`Mastermind"' der Applikation, welche die Entscheidungen trifft. Hierbei wird einerseits eine enorm hohe Arbeitsgeschwindigkeit ermöglicht, da die beiden Sprachen relativ hardwarenah agieren und andererseits besteht der nicht zu unterschätzende Vorteil bzw. die Möglichkeit, den Rechenkern auf ein externes System outzusourcen, welches zum Beispiel enorme Rechenkapazitäten aufweisen könnte und somit viel komplexere und effizientere Algorithmen in annehmbarer Zeit durchrechnen und abhängig davon mehr gewinnbringende Entscheidungen treffen könnte. Dabei sollte es auch bei späteren Erweiterungen des Programms zu keinem signifikanten Geschwindigkeitsabfall kommen.


\begin{center}

\begin{tabular}{ | c | p{2.6cm} | p{1.7cm} | p{0.5cm} |p{0.5cm}|p{0.5cm}|p{0.5cm}|p{0.7cm}|p{0.6cm}|}
\hline 
\multicolumn{2}{|p{1.5cm}|}{ }  & Gewicht\-ung & \multicolumn{2}{p{1.5cm}|}{\textbf{C++ R*G}} & \multicolumn{2}{p{1.5cm}|}{\textbf{Java R*G}} & \multicolumn{2}{|p{1.5cm}|}{\textbf{C\#F\# R*G}}\\ \hline
\multirow{6}{*}{Einfachheit} & Aufwand Coding & 10\% & 3 & 30 & 1 & 10 & 2 & 20 \\ \cline{2-9}
& Bedienung/ Wartung & 6\% &3&9&2&6&1&3\\ \cline{2-9}
& Update &3\%&3&9&2&6&1&3\\ \cline{2-9}
& Integration &5\%&3&15&2&10&1&5\\  \cline{2-9}
& Kenntnisse &6\%&3&18&1&6&2&12\\ \cline{2-9}
& \textbf{Gesamt}&30\%&3&81&2&38&1&43\\ \hline
\multirow{5}{*}{Leistung}& Über\-tra\-gungs\-zeit &6\%&1&6&3&18&2&12\\ \cline{2-9}
& Absturz\-sicherheit &5\%&1&5&2&10&3&15\\ \cline{2-9}
& Ressourcen-verbrauch &3\%&1&3&3&9&2&6\\ \cline{2-9}
& Daten\-umfang &1\%&1&1&3&3&2&2\\ \cline{2-9}
& \textbf{Gesamt} &15\%&1&15&3&50&2&35\\ \hline
\multirow{5}{*}{Kosten}& Lizenzen &10\%&1&10&1&10&1&10\\ \cline{2-9}
& Support &5\%&3&15&1&5&2&10\\ \cline{2-9}
& Betriebs-kosten &5\%&1&5&1&5&1&5\\ \cline{2-9}
& Dokumen\-tation &5\%&1&5&2&20&3&15\\ \cline{2-9}
& \textbf{Gesamt} &15\%&1&30&1&40&2&40\\ \hline
\multirow{4}{*}{Dokumentation}& Verfügbarkeit &10\%&3&30&2&20&1&10\\ \cline{2-9}
& Voll\-ständigkeit &10\%&3&30&2&20&1&10\\ \cline{2-9}
& Qualität &10\%&2&20&1&10&1&10\\ \cline{2-9}
& \textbf{Gesamt} &30\%&3&80&2&50&1&30\\ \hline
\end{tabular}

\end{center} 

\begin{center}

\begin{tabular}{|l|r|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|} \hline
Kapitel&Gewichtung&\multicolumn{2}{p{1.8cm}|}{\textbf{C++}}&\multicolumn{2}{p{1.8cm}|}{\textbf{Java}}&\multicolumn{2}{p{1.8cm}|}{\textbf{C\#/F\#}}\\ \hline
Einfachheit&30\%&3&81&2&44&1&46 \\ \hline
Leistung&15\%&1&15&3&50&2&35 \\ \hline
Kosten&15\%&2&30&2&40&1&40 \\ \hline
Dokumentation&30\%&3&80&2&50&1&30 \\ \hline
\end{tabular}

\end{center}

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
Gesamtbewertung&&&\\ \hline
Endreihung &3&2&1\\ \hline
\end{tabular}
\end{center}

Aus der Nutzwertanalyse kann man entnehmen, dass die C\#/F\# Kombination als die beste Möglichkeit hervorgeht, weitere Vorteile, die sich aus der Wahl dieser Mischung ergeben sind: gute Kenntnisse der Programmiersprachen, eine hilfreiche Community, Einfachheit und Erweiterbarkeit. Bei dieser Lösung wird die Steuereinheit vom C\# Teil des Programms übernommen und die Rechenaufgaben werden von dem F\# Teil bearbeitet. Außerdem ist das .net-Framework sehr beliebt, deswegen kann man damit rechnen, dass bei einem Problem genügend Helfer gefunden werden können. \\

Nach dem Festlegen der verwendeten Programmiersprachen ist es nun auch möglich, in C\# zwischen zwei verschiedenen Grafikframeworks für die GUI der \gls{bts} zu wählen. Da Windows Presentation Foundation (WPF) neuer ist und Windows Forms (WF) nicht auf dem Model-View-Controller-Pattern (MVC) basiert, wird das Framework WPF angewendet.

\subsection{Backtesting-Software}
Bei der \gls{bts} handelt es sich, wie bereits erwähnt, um eine Software, die Algorithmen auf ihre Performance und weitere wichtige Kriterien testet.
Um diese Aufgabe zu lösen, müssen drei wichtige Entscheidungen zur Art der Realisierung getroffen werden:

\begin{itemize}
	\item Ist es sinnvoller, diese Software über eine \gls{gui} steuern zu können, oder reicht es, wenn sie in der Konsole arbeitet? 
	\item Auf welche Art und Weise soll der Algorithmus, der getestet werden soll, zur Laufzeit in die Software eingebunden werden?
	\item In welcher Weise werden die Algorithmen, die von der \gls{bts} getestet werden, versioniert und wie werden die Testergebnisse gespeichert?
\end{itemize}

Gehen wir nun also zuerst der Frage nach dem User-Interface nach.
Bei einem großen Anteil der Zielgruppe dieser \gls{bts} handelt es sich um Chartisten oder andere sehr visuelle Personen. Diese würden vermutlich eine graphische Oberfläche bevorzugen, da sie dabei z.B. auch ihren Algorithmus so erweitern könnten, dass dieser die Charts, die ihm zu Grunde liegen, in einem neuen Fenster darstellt und man dadurch einen noch besseren Überblick über das Geschehen des Algorithmus erlangen könnte. Andererseits wird es sich aber auch bei einem großen Teil der Zielgruppe um technische Programmierer und Mathematiker handeln, die wieder nicht so viel Wert auf eine graphische Oberfläche legen, da sie eher in Zahlen als in Bildern denken. Allerdings wäre mit Sicherheit fast niemand dieser Gruppe strikt gegen eine Graphische Oberfläche. Es ist hierbei nur abzuwägen, ob der erhöhte Aufwand den, die Codierung einer solchen \gls{gui} mit sich bringen würde, sinnvoll ist und wirklich eine höhere Anzahl an Kunden interessieren würde. Mit einer \gls{gui} wäre es allerdings auch erheblich einfacher, einen Algorithmus einzubinden.\\
\\
Es erscheint dem Projektteam aufgrund der Programmiersprachenwahl am sinnvollsten, dass die User den Algorithmus in der Sprache F\# schreiben und diesen als \gls{dll} konvertieren müssen, um ihn in die Software zu integrieren. Grundsätzlich ist es dadurch in jedem Fall notwendig, dass mit der \gls{bts} als Download zusätzlich ein Interface (zur Beschreibung von Methodennamen, die benutzt werden, usw.) und eine Beispiel-\gls{dll} bereitgestellt werden, damit die Nutzer der Software einen schnellen und einfachen Überblick bekommen, wie sie ihre \glspl{dll} aufbereiten müssen, um diese problemlos in die \gls{bts} integrieren zu können. Durch die Frage, wie die Integration eine solchen \gls{dll} nun wirklich am einfachsten für unsere zukünftigen Benutzer wäre, ergeben sich zwei Möglichkeiten zur Aufbereitung und Einbindung eines Algorithmus. Man könnte den Algorithmus einfach zur Laufzeit in die Software laden, in dem z.B. die Software ein Dateisystem-Browsing anbietet, in dem man die Algorithmus-\gls{dll} einfach auswählt, diese wird automatisch in die Software integriert und so der Algorithmus getestet. Würde die Software als Konsolenapplikation laufen, wäre dies schon etwas komplizierter für unerfahrene Nutzer, da man ein bestimmtes Kommando und den direkten Pfad zur Algorithmus-\gls{dll} selbst eintippen müsste. Eine ganz andere Möglichkeit wäre es, den Algorithmus als eigenständige Applikation bereitzustellen, auf die man über Sockets eine Verbindung aufbauen und die Rechenoperationen an sie auslagern kann. Auf diese Art und Weise wäre es ebenfalls möglich den Algorithmus zu testen, allerdings müsste das Projektteam eine viel umfangreichere Beispiel-\gls{dll} bereitstellen, in der die Eigenständigkeit der Software, sowie die Erreichbarkeit über Sockets direkt nach ihrem Start bereits vordefiniert sein müssten. Dies würde zu einem etwas erhöhten Aufwand für das Projektteam führen, wobei dies nicht das Hauptproblem dieser Variante darstellt. Denn durch die umfangreiche anfangs mit Sicherheit unübersichtliche Beispiel-\gls{dll} würden programmiertechnisch unerfahrene Benutzer schnell zurückschrecken und lieber Konkurrenzprodukte benutzen als sich in dieses Produkt aufwendig einzulesen.\\
\\
Da es sich bei Noctua um ein Projekt handelt, welches versucht, einen möglichst profitablen Handelsalgorithmus zu erstellen und die \gls{bts} eigentlich nur ein Mittel zum Vergleich der unterschiedlichen Algorithmen ist, liegt es nahe, dass im Zuge der Algorithmuserforschung alle geschriebenen Algorithmen zu jedem Testzeitpunkt gespeichert werden sollten. Außerdem wäre es erheblich von Vorteil wenn man eine Möglichkeit hätte immer alle Versionen des Algorithmus anhand ihrer von der \gls{bts} ermittelten Testergebnisse vergleichen können. Dafür muss eine Ansammlung an Daten erzeugt werden, die es ermöglicht, auch auf Rückschritte in der Performance des Algorithmus aufmerksam zu werden. Zudem sollen diese Daten zur Senkung des Aufwandes beim Tester automatisch von der \gls{bts} erstellt werden. Dafür gibt es nun zwei Möglichkeiten. Man könnte eine Datenbank aufbauen, die jeweils die getestete Version des Algorithmus zusammen mit seinen Testergebnissen (Performance, ...) in einem Datensatz speichert. Diese Lösung klingt grunsätzlich recht sinnvoll, doch bringt sie zwei Probleme mit sich. Das erste Problem ist die Speicherung des Algorithmus. Dieses könnte man allerdings über die Speicherung des algorithmus.dll-Files als Binary-Large-Object oder durch die Speicherung des Pfades zur Algorithmus-Datei lösen. Allerdings ist es nicht so einfach, die generellen Userwünsche zu ändern. Es ist nämlich nur ein kleiner Anteil unserer zukünftigen User gewillt, sich eine Datenbank einzurichten, nur um eine Versionierung ihrer Algorithmen zu bekommen. Deswegen hat sich das Projektteam entschieden, von der \gls{bts} einfache Dateien generieren zu lassen, die den Pfad zur Algorithmus-Datei und die dazu ermittelten Testergebnisse speichert. Außerdem wird im Zuge der Umsetzung von Noctua eine Dateistruktur für sowohl die Dokumentations- als auch die Algorithmus-Dateien entworfen. \\
\\
Durch diesen gesamten Analysevorgang kam das Projektteam zu dem Schluss, dass es für die zukünftige Zielgruppe des Produkts wohl am einfachsten und damit auch am sinnvollsten wäre, dieses Produkt mit einer \gls{gui} zu realisieren, da es sich bei der Zielgruppe meist zwar um börsenerfahrene Personen handelt, diese aber wahrscheinlich nicht so standfest in der Welt des .net-Frameworks sind. Außerdem ermöglicht eine simple \gls{gui} die Einbindung eines Algorithmus mittels Dateisystem-Browsing, ohne dass der Benutzer mühsamst den Pfad selbst suchen und in die Software einfügen muss. Als Variante zur Einbindung des Algorithmus erscheint es dem Projektteam ebenfalls am sinnvollsten, den Algorithmus einfach über ein Interface mit einer ganz normalen \gls{dll} einzubinden, da es aufwendiger und wahrscheinlich auch langsamer wäre, den Algorithmus als eigenständige Software über Sockets anzusprechen. Zur Versionierung der Algorithmen wird die \gls{bts} eine Dateistruktur aus Dokumentations- und Algorithmus-Dateien anlegen, die alle Testergebnisse und Algorithmen speichert.\\
\\
Im Zuge der Überprüfung der Machbarkeit der \gls{bts} wurde auch ein Prototyp erstellt. Dieser testet, wie die Algorithmus-Datei am besten in die \gls{bts} eingebunden werden kann. Dies ist ein wenig komplizierter als es auf den ersten Blick aussieht, da der Code ja zur Laufzeit aus der \gls{dll} in die \gls{bts} eingebunden werden soll. Außerdem muss die \gls{bts} in diesem Code auch Operationen ausführen können. Dazu stellt das .net-Framework eine ziemlich praktische Hilfestellung, durch die Unterstützung von Assemblies, zur Verfügung. Der Kern des Codes zur Integration des Algorithmus sieht so aus:

\begin{verbatim}
Assembly assembly = Assembly.LoadFrom(algorithmFileName);
AppDomain.CurrentDomain.Load(assembly.GetName());
Type t = assembly.GetType("DecisionCalculator");
            
var signal = t.GetMethod("getDecision").Invoke(null, oa);
\end{verbatim}

Dies ermöglicht die Implementierung der geplanten Funktionalitäten der \gls{bts} und beweist, dass es machbar ist, einen Algorithmus zur Laufzeit zu integrieren.