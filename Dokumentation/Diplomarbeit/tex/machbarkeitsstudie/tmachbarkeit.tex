\section{Technische Machbarkeit}\label{section:technischemachbarkeit}
\subsection{Variantenbildung}
\subsubsection{Programmiersprachen}
Die \gls{bts} kann man in jeder erdenklichen Programmiersprache schreiben, allerdings ist es wichtig daran zu denken, dass das Programm einerseits effizient arbeiten soll und deswegen hardwarenahe rechnet, und andererseits hat das Projektteam mit manchen Programmiersprachen keinerlei Erfahrung.\\
Die allgemeine Funktionalität muss das lesen und schreiben von Dateien sein, aber auch das algorithmische Rechnen soll effizient funktionieren. Für das Team kommen daher 3 Möglichkeiten in Frage: Eine Lösung in reinem C++, welches sehr hardwarenahe arbeitet, eine Mischung aus F\# und C\#, mit der eine parallelisierte Berechnung möglich wäre, und eine Java-Lösung, bei der das Team die größte Erfahrung mitbringt. \\
Bei der Kombination agiert C\# als Handlungs- und Steuerkern und F\# als funktionale Programmiersprache, als Rechenkern und \"Mastermind\" der Applikation, welches die Entscheidungen trifft. Hierbei wird einerseits eine enorm hohe Arbeitsgeschwindigkeit ermöglicht, da die beiden Sprachen relativ hardwarenah agieren und andererseits besteht der nicht zu unterschätzende Vorteil bzw. die Möglichkeit, den Rechenkern auf ein externes System outzusourcen, welches zum Beispiel enorme Rechenkapazitäten aufweisen könnte und somit viel komplexere und effizientere Algorithmen in annehmbarer Zeit durchrechnen und abhängig davon mehr gewinnbringende Entscheidungen treffen könnte. Dabei sollte es auch bei späteren Erweiterungen des Programms zu keinem signifikanten Geschwindigkeitsabfall kommen.


\begin{center}

\begin{tabular}{ | c | p{2.6cm} | p{1.7cm} | p{0.5cm} |p{0.5cm}|p{0.5cm}|p{0.5cm}|p{0.7cm}|p{0.7cm}|}
\hline 
\multicolumn{2}{|p{1.5cm}|}{ }  & Gewicht\-ung & \multicolumn{2}{p{1.5cm}|}{\textbf{C++ R*G}} & \multicolumn{2}{p{1.5cm}|}{\textbf{Java R*G}} & \multicolumn{2}{|p{1.5cm}|}{\textbf{C\#F\# R*G}}\\ \hline
\multirow{6}{*}{Einfachheit} & Aufwand Coding & 10\% & 3 & 30 & 1 & 10 & 2 & 20 \\ \cline{2-9}
& Bedienung/ Wartung & 6\% &3&9&2&6&1&3\\ \cline{2-9}
& Update &3\%&3&9&2&6&1&3\\ \cline{2-9}
& Integration &5\%&3&15&2&10&1&5\\  \cline{2-9}
& Kenntnisse &6\%&3&18&1&6&2&12\\ \cline{2-9}
& \textbf{Gesamt}&30\%&3&90&2&44&1&46\\ \hline
\multirow{5}{*}{Leistung}& Übertragungs-zeit &6\%&1&6&3&18&2&12\\ \cline{2-9}
& Absturz\-sicherheit &5\%&1&5&2&10&3&15\\ \cline{2-9}
& Ressourcen-verbrauch &3\%&1&3&3&9&2&6\\ \cline{2-9}
& Datenumfang &1\%&1&1&3&3&2&2\\ \cline{2-9}
& \textbf{Gesamt} &15\%&1&15&3&50&2&35\\ \hline
\multirow{5}{*}{Kosten}& Lizenzen &10\%&1&10&1&10&1&10\\ \cline{2-9}
& Support &5\%&3&15&1&5&2&10\\ \cline{2-9}
& Betriebs-kosten &5\%&1&5&1&5&1&5\\ \cline{2-9}
& Dokumen\-tation &5\%&1&5&2&20&3&15\\ \cline{2-9}
& \textbf{Gesamt} &15\%&1&30&1&40&2&40\\ \hline
\multirow{4}{*}{Dokumentation}& Verfügbarkeit &10\%&3&30&2&20&1&10\\ \cline{2-9}
& Voll\-ständigkeit &10\%&3&30&2&20&1&10\\ \cline{2-9}
& Qualität &10\%&2&20&1&10&1&10\\ \cline{2-9}
& \textbf{Gesamt} &30\%&3&80&2&50&1&30\\ \hline
\end{tabular}

\end{center} 

\begin{center}

\begin{tabular}{|l|r|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|p{0.8cm}|} \hline
Kapitel&Gewichtung&\multicolumn{2}{p{1.8cm}|}{\textbf{C++}}&\multicolumn{2}{p{1.8cm}|}{\textbf{Java}}&\multicolumn{2}{p{1.8cm}|}{\textbf{C\#/F\#}}\\ \hline
Einfachheit&30\%&3&90&2&44&1&46 \\ \hline
Leistung&15\%&1&15&3&50&2&35 \\ \hline
Kosten&15\%&2&30&2&40&1&40 \\ \hline
Dokumentation&30\%&3&80&2&50&1&30 \\ \hline
\end{tabular}

\end{center}

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
Gesamtbewertung&&&\\ \hline
Endreihung &3&2&1\\ \hline
\end{tabular}
\end{center}

Aus der Nutzwertanalyse kann man entnehmen, dass die C\#/F\# Kombination als die favorisierte Möglichkeit ausgeht, weitere Vorteile die sich aus der Wahl dieser Mischung ergeben sind: gute Kenntnisse der Programmiersprachen, tolle Community und die Einfachheit, sowie die Erweiterbarkeit. Bei dieser Lösung wird die Steuereinheit vom C\# Teil des Programms übernommen und die Rechenaufgaben werden von dem F\# Teil bearbeitet. Außerdem ist das .net-Framework sehr beliebt, deswegen kann man damit rechnen das bei einem Problem genügend Helfer gefunden werden können.

\subsubsection{\gls{bts}}
Bei der \gls{bts} handelt es sich wie bereits erwaehnt, um eine Software, die Algorithmen auf ihre Performance und weitere wichtige Kriterien testet.
Um diese Aufgabe zu lösen, müssen zwei wichtige Entscheidungen zur Art der Realisierung getroffen werden:

\begin{itemize}
	\item Ist es sinnvoller diese Software über eine \gls{gui} steuern zu können, oder reicht es wenn sie in der Konsole arbeitet? 
	\item Auf welche Art und weise soll der Algorithmus der getestet werden soll, zur Laufzeit in die Software eingebunden werden.?
\end{itemize}

Gehen wir nun also zuerst der Frage nach dem User-Interface nach.\\
Bei einem großen Anteil der Zielgruppe dieser \gls{bts} handelt es sich um Chartisten oder andere sehr visuelle Personen. Diese würden vermutlich eine graphische Oberfläche bevorzugen, da sie dabei z.B. auch ihren Algorithmus so erweitern könnten, dass dieser die Charts die ihm zu Grunde liegen in einem neuen Fenster darstellt und man dadurch einen noch besseren Überblick über das Geschehen des Algorithmus erlangen könnte. Andererseits wird es sich aber auch bei einem großen Teil der Zielgruppe, um Technische Programmierer und Mathematiker handeln, die wieder nicht so viel Wert auf eine graphische Oberfläche legen, da sie eher in Zahlen, als in Bildern denken. Allerdings wäre mit Sicherheit fast niemand dieser Gruppe strikt gegen eine Graphische Oberfläche. Es ist hierbei nur abzuwiegen, ob der erhöhte Aufwand den die Codierung einer solchen \gls{gui} mit sich bringen würde, sinnvoll ist und wirklich eine höhere Anzahl an Kunden interessieren würde. Mit einer \gls{gui} wäre es allerdings auch erheblich einfacher, einen Algorithmus einzubinden.\\
\\
Es erscheint dem Projektteam aufgrund der Programmiersprachenwahl am sinnvollsten, dass die User den Algorithmus in der Sprache F\# schreiben und diesen als \gls{dll} konvertieren müssen, um ihn in die Software zu integrieren. Grundsätzlich ist es dadurch in jedem Fall notwendig, dass mit der \gls{bts} als Download zusätzlich ein Interface(zur Beschreibung von Methoden-Namen die benutzt werden, usw.) und eine Beispiel-\gls{dll} bereitgestellt werden, damit die Nutzer der Software einen schnellen und einfachen Überblick bekommen, wie sie ihre \glspl{dll} aufbereiten müssen, um diese problemlos die \gls{bts} integrieren zu können. Durch die Frage, wie die Integration eine solchen \gls{dll} nun wirklich am einfachsten für unsere zukünftigen Benutzer wäre, ergeben sich zwei Möglichkeiten zur Aufbereitung und Einbindung eines Algorithmus. Man könnte den Algorithmus einfach zur Laufzeit in die Software laden, indem z.B. die Software ein Dateisystem-Browsing anbietet, indem man die Algorithmus-\gls{dll} einfach auswählt und diese wird automatisch in die Software integriert und so der Algorithmus getestet. Würde die Software als Konsolenapplikation laufen, wäre dies schon etwas komplizierter für unerfahrene Nutzer, da man ein bestimmtes Kommando und den direkten Pfad zur Algorithmus-\gls{dll} selbst eintippen müsste. Eine ganz andere Möglichkeit wäre es den Algorithmus als eigenständige Applikation bereitzustellen, auf die man über Sockets eine Verbindung aufbauen und die Rechenoperationen an sie auslagern kann. Auf diese Art und Weise wäre es ebenfalls möglich den Algorithmus zu testen, allerdings müsste das Projektteam eine viel Umfangreichere Beispiel-\gls{dll} bereitstellen, in der die Eigenständigkeit der Software, sowie die Erreichbarkeit über Sockets direkt nach ihrem Start bereits vordefiniert sein müssten. Dies würde zu einem etwas erhöhten Aufwand für das Projektteam führen, wobei dies nicht das Hauptproblem dieser Variante darstellt. Denn durch die umfangreiche anfangs mit Sicherheit unübersichtliche Beispiel-\gls{dll} würden programmiertechnisch unerfahrene Benutzer schnell zurückschrecken und lieber Konkurrenzprodukte benutzen, als sich in dieses Produkt aufwendig einzulesen.\\
\\
Durch diesen gesamten Analysevorgang kam das Projektteam zu dem Schluss, dass es für die zukünftige Zielgruppe des Produkts wohl am einfachsten und damit auch am sinnvollsten wäre, dieses Produkt mit einer \gls{gui} zu realisieren, da es sich bei der Zielgruppe meist zwar um Börsenerfahrene Personen handelt, diese aber wahrscheinlich nicht so standfest in der Welt des .net-Frameworks sind. Außerdem ermöglicht eine simple \gls{gui}, die Einbindung eines Algorithmus mittels Dateosystem-Browsing, ohne dass der Benutzer mühsamst den Pfad selbst suchen und in die Software einfügen muss. Als Variante zur Einbindung es algorithmus erscheint es dem Projektteam ebenfalls am sinnvollsten den Algorithmus einfach über ein Interface mit einer ganz normalen \gls{dll} einzubinden, da es aufwendiger und wahrscheinlich auch langsamer wäre, den Algrithmus als eingenständige Software über Sockets anzustprechen.