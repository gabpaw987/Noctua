\subsection{Windows Presentation Foundation} \label{wpf}

Mit Version 3.0 des .NET-Frameworks wurde wie bereits erwähnt zusätzlich zur altbewährten WinForms-Variante, eine neue Variante integriert um Benutzeroberflächen einfach zu implementieren. Diese heißt \gls{wpf}. \cite{visualcsharp}\\
\\
Das wichtigste Merkmal von \gls{wpf} gegenüber anderen Methoden zur \gls{gui}-Erstellung ist, dass bei \gls{wpf} die Programmlogik nach strengsten Richtlinien von der Beschreibung der Oberfläche trennt. Diese Beschreibung der Oberfläche erfolgt mittels einer speziellen Version der normalen \gls{xml}, der \gls{xaml}. Mit dieser Sprache werden alle \gls{gui}-Komponenten, erzeugt und in die entsprechende Position gebracht. Bei \gls{wpf} wird allerdings trotzdem auch eine \gls{api} für den Zugriff auf \gls{xaml}-\gls{gui}-Komponenten innerhalb der Programmlogik bereit gestellt. Bei der Erstellung eines \gls{wpf}-Projektes, bekommt man automatisch ein MainWindow.xaml-File. Ein solches \gls{xaml}-File das lediglich einen Button als \gls{gui} anzeigt, würde nun in etwa so aussehen: \cite{visualcsharp}\\
\\
\begin{verbatim}
<Window x:Class="Wpf1Application1.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    Title="MainWindow" Height="350" Width="525">
    <Grid>
    	<Button Name="button1">Button</Button>
    <\Grid>
</Window>
\end{verbatim}

Hierbei werden zuerst die nötigen von Microsoft definierten \gls{xaml}-Namespaces angegeben. Anschließend werden ein Titel (der ganz oben im Fenster angezeigt wird) und die Größe des Fensters angegeben, dass später unseren Button beinhalten soll. Danach wird ein einfaches Grid-Layout mit einem Button mit dem Text "Button" gezeichnet. Ab Microsoft Visual Studio 2008, wird auch ein \gls{wpf}-\gls{gui}-Builder bei der Installation mitgegeben, mit dem man diese \gls{xaml}-Dateien einfach mit graphischer Oberfläche erstellen kann. \cite{visualcsharp}\\
\\
Zu der MainWindow.xaml-Datei wird auch noch eine weitere Datei mit dem Namen MainWindow.xaml.cs erstellt. Diese wird auch als \textit{Code-Behind}-Datei bezeichnet und beinhaltet den Teil der Programmlogik der direkt mit der graphischen Oberfläche verknüpft ist. Möchte man also bspw. die Logik implementieren, die beschreibt was bei einem Klick auf den Button passiert, müsste man dies in eben dieser MainWindow.xaml.cs-Datei durchführen. \cite{visualcsharp}

\subsubsection{MVVM}
Als \gls{mvvm} wird ein Entwicklungsmuster (Design-Pattern) verstanden, dass sehr oft in Verbindung mit der Implementierung von \gls{wpf}-Oberflächen eingesetzt wird. Dabei werden die einzelnen Aufgaben einer Anwendung mit graphischer Oberfläche in drei Teile aufgeteilt. Es gibt nun ein View, ein Model und ein ViewModel. Deren Interaktion kann in der Abbildung \ref{fig:mvvm} sehr schön nachvollzogen werden. \cite{msdn-mvvm}\\

\begin{figure}[h]
	\centering
		\includegraphics[width=0.90\textwidth]{graphics/grundlagen/mvvm.png}
	\caption{Aufbau von \gls{mvvm}}
	\label{fig:mvvm}
\end{figure}

Zuerst gibt es da also den View-Teil. Der View beschreibt das Aussehen der \gls{gui}. Im Optimalfall befindet sich um View ausschließlich ein Konstruktor mit einem Methodenaufruf InitializeComponents(), der die \gls{gui} über das \gls{xaml}-File aufbaut. Sollen allerdings komplexere graphisch aufwendigere Elemente oder Animationen in der grafischen Oberfläche gezeichnet werden, kann diese Logik im View-Teil implementiert werden. Im View sollte allerdings nie Logik programmiert werden die man einem Unit-Testing unterziehen muss.\\ Wie der Abbildung \ref{fig:mvvm} entnommen werden kann, kommunziert der View nicht direkt, sondern ausschließlich über Commands, Notifications oder Data Binding mit dem ViewModel. Auf Commands wird hier nicht näher eingegangen, Data Binding und Notifications können allerdings im folgenden Abschnitt \ref{databinding} gefunden werden. \cite{msdn-mvvm}\\
\\
Der ViewModel-Teil kapselt nun die Presentationslogik und die von der \gls{gui} benötigten Daten. Das ViewModel hat keinen direkten Zugriff auf den View und weißt daher nichts über dessen Implementierung. Das ViewModel kann bspw. über die Verwaltung von Daten, die mittels Data Binding an den View weitergegeben werden mit diesem kommunizieren. Nebenbei bemerkt, müssen alle Daten die über Data Binding an den View weitergegeben werden sollen ausschließlich im ViewModel gespeichert werden. Das ViewModel beschreibt also welche Funktionalität die \gls{gui} anbieten soll und das View, wie diese angezeigt wird. Das ViewModel fungiert außerdem quasi als Mittelmann zwischen dem View und dem Model und kann dabei bspw. noch die Daten aus dem Model so vereinfachen, dass der View diese leichter verarbeiten kann. \cite{msdn-mvvm}\\
\\
Das Model ist nun die eigentliche Geschäfts- oder Programmlogik und die damit verbundenen allgemeinen Daten. Hierbei handelt es sich um eine ganz normale Geschäftslogik wie in anderen Anwendungen auch, nur dass noch einmal speziell Wert darauf gelegt werden sollte die einzelnen Codestücke nicht Task-spezifisch zu implementieren, um die einzelnen Stück später möglicherweise an anderen Stellen wiederverwenden zu können. Außerdem besteht das Model entgegen dem View und dem Viewmodel meist aus vielen einzelnen Model-Klassen, die alle mit dem selben ViewModel kommunizieren. Möchte das Model auch mit dem View interagieren gibt es auch hier die Möglichkeit Notifications zu benutzen.\cite{msdn-mvvm}

\subsubsection{Data Binding} \label{databinding}

Das Data Binding (auch: Datenbindung) ermöglicht \gls{gui}-Komponenten den Zugriff auf Daten, die sie anzeigen können. In WinForms war die Datenbindung auch schon integriert, lediglich war man mit den damaligen Methoden auf wenige Controls beschränkt. Mit \gls{wpf} ist man dies nun nicht mehr. Daten können hiermit nämlich direkt aus einer der folgenden Datenquellen entnommen werden \cite{visualcsharp}:

\begin{itemize}
	\item ViewModel
	\item Eigenschaften anderer Komponenten
	\item \gls{xml}-Datei
	\item Collections
	\item Datenbanken
	\item etc.
\end{itemize} \cite{visualcsharp}

Zur Nutzung von Data Binding sind nun zwei Klassen wichtig, DataContext und Binding. Der DataContext ist die Datenquelle von der die Daten bezogen werden sollen. Dieser DataContext ist außerdem ein Attribut jedes \gls{gui}-Elements und muss gesetzt werden, damit Bindungen funktionieren. Möchte man nun den DataContext setzen sollte man aber aufpassen und ihn im übergeordneten Container (z.B. dem MainWindow) setzen, denn davon profitieren alle untergeordneten Komponenten dieses Conatiners und der DataContext muss nict überall gesetzt werden. Das Binding-Objekt beschreibt nun die Binung zwischen einer Datenquelle und einer bindenden Komponente. Das Binding wird meist im \gls{xaml}-Code geschrieben, es besteht allerdings selbstverständlich auch die Möglichkeit sie innerhalb des C\#-Codes zu erzeugen. \cite{visualcsharp}\\
\\
Das einfachste Beispiel für eine Bindung könnte nun in etwa so aussehen:

\begin{verbatim}
<Window x:Class="Wpf1Application1.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    Title="MainWindow" Height="350" Width="525">
    <Window.DataContext>
    	<local:MainViewModel x:Name="mainViewModel" />
    </Window.DataContext>
    <StackPanel>
    	<TextBox Name="txtOben" Height="50" FontSize="16"></TextBox>
    	<TextBox Name="txtUnten" Height="50" Background="AliceBlue" FontSize="16">
    		<Binding ElementName="txtOben" Path="Text" />
    	</TextBox>
    </StackPanel>
</Window>
\end{verbatim} \cite{visualcsharp}

Zuerst wird hier der \textit{DataContext} auf das ViewModel gesetzt. Dies wäre hier zwar noch nicht notwendig, da keine Bindung auf ein Property aus dem ViewModel erfolgt, es zeigt allerdings die angesprochene Funktionsweise und wird im nächsten Beispiel von Bedeutung sein. Danach werden zwei \textit{TextBoxen} erstellt von denen die Text-Variable der unteren eine Bindung auf die Text-Variable der oberen besitzt. Dadurch wird der Text der unteren \textit{TextBox} automatisch an den Text der oberen \textit{TextBox} angepasst, falls sich dieser ändert. Eine Bindung in dieser Art könnte aber auch auf jedes andere Attribute der \textit{TextBoxen} (z.B. Größe, Schriftart, etc.) angewendet werden. Dazu müsste lediglich der \textit{Path} der Bindung geändert werden. \cite{visualcsharp}\\
\\
Eine etwas kompliziertere Bindung ist die auf ein Property aus dem ViewModel. Dazu muss man zuerst im ViewModel ein Property erzeugen und dessen setter-Methode für die Nutzung von Notifications implementieren. Das Property, das die Lieblingsfarbe einer Person speichert, könnte dann in etwa so aussehen \cite{msdn-mvvm}:

\begin{verbatim}
public class MyViewModel : INotifyPropertyChanged
{
    private string favoriteColor;
    public event PropertyChangedEventHandler PropertyChanged;
    ...
    public string FavoriteColor
    {
        get { return this.favoriteColor; }
        set
        {
            if (value != this.favoriteColor)
            {
                this.favoriteColor = value;
                if (this.PropertyChanged != null)
                {
                    this.PropertyChanged(this,
                          new PropertyChangedEventArgs("FavoriteColor"));
                }
            }
        }
    }
}
\end{verbatim} \cite{msdn-mvvm}

Hierbei wird einfach eine globale Variable (\textit{favoriteColor}) mit einem Property (\textit{FavoriteColor}) versehen, das die setter-Methode so implementiert hat, dass ein \textit{PropertyChangedEvent} gesendet wird, sobald der Wert der Lieblingsfarbe geändert wird. Dies ist notwendig, wenn man das Property an ein \gls{gui}-Element binden will, da sich das \gls{gui}-Element, sonst im Falle einer Änderung der Lieblingsfarbe nicht aktualisieren würde. Möchte man dieses Property nun im \gls{xaml}-Code an ein \gls{gui}-Element binden, muss man lediglich das Folgende schreiben:

\begin{verbatim}
<Window x:Class="Wpf1Application1.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    Title="MainWindow" Height="350" Width="525">
    <Window.DataContext>
    	<local:MainViewModel x:Name="mainViewModel" />
    </Window.DataContext>
    <StackPanel>
    	<TextBox Name="favoriteColorTextBox" Height="50" FontSize="16">
    		<Binding Path="FavoriteColor" />
    	</TextBox>
    </StackPanel>
</Window>
\end{verbatim}

Diesmal ist die Definition des ViewModels als \textit{DataContext} notwendig. Aus diesem wird nämlich einfach in der Bindung das \textit{FavoriteColor}-Property aufgerufen. Schon steht zu jeder Zeit die aktuelle Lieblingsfarbe aus dem ViewModel in der \textit{TextBox}.