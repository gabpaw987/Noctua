\chapter{Realisierungsvarianten} \label{chapter:varianten}
\lstset{style=sharpc}
\section{Programmiersprachen}
Bei der Programmierung der \gls{bts} ist es wichtig die Interoperabilität zu einem dynamisch ladbaren Algorithmus zu erhalten. Weitere wichtige Punkte, die erfüllt werden müssen, sind die mathematische Berechnung von performancerelevanten Daten und das effiziente Einlesen und Abarbeiten von Daten. \\
Eine gute Wahl ist die Kombination einer objektorientieren und einer funktionalen Programmiersprache, eine C\#-, F\#-Kombination bietet sich hierbei an. Bei dieser Kombination ist die C\#-Seite die \gls{bts}, welche Daten einliest und Ergebnisse interpretiert. Beim F\#-Softwareprodukt handelt es sich nicht um eine gewohnte Konsolen- oder GUI-Applikation, sondern um eine DLL, welche dynamisch in die \gls{bts} eingebunden werden kann und diese mit Entscheidungen versorgt. Bei dieser Lösung kommt es zu keinem Problem, wenn der Algorithmus (ursprünglich F\#) auch in einer anderen .NET-Sprache geschrieben wird und als Programmbibliothek exportiert wird. 


\section{Backtesting-Software}
Bei der \gls{bts} handelt es sich um eine Software, die Algorithmen auf ihre Performance testet.
Um diese Aufgabe zu lösen, müssen drei wichtige Entscheidungen zur Art der Realisierung getroffen werden:

\begin{itemize}
	\item Ist es sinnvoller, diese Software über eine \gls{gui} steuern zu können, oder reicht es, wenn sie in der Konsole arbeitet? 
	\item Auf welche Art und Weise soll der Algorithmus, der getestet werden soll, zur Laufzeit in die Software eingebunden werden?
	\item In welcher Weise werden die Algorithmen, die von der \gls{bts} getestet werden, versioniert und wie werden die Testergebnisse gespeichert?
\end{itemize}

Gehen wir nun also zuerst der Frage nach dem User-Interface nach.
Bei einem großen Anteil der Zielgruppe der \gls{bts} handelt es sich um Chartisten oder andere sehr visuell orientierte Personen. Diese würden vermutlich eine graphische Oberfläche bevorzugen, da sie dabei z.B. auch ihren Algorithmus so erweitern könnten, dass dieser die Charts, die ihm zu Grunde liegen, in einem neuen Fenster darstellt und man dadurch einen noch besseren Überblick über das Geschehen des Algorithmus erlangen könnte. Andererseits wird es sich aber auch bei einem großen Teil der Zielgruppe um technische Programmierer und Mathematiker handeln, die wiederum nicht so viel Wert auf eine graphische Oberfläche legen, da sie eher in Zahlen als in Bildern denken. Allerdings wäre mit Sicherheit fast niemand dieser Gruppe strikt gegen eine Graphische Oberfläche. Es ist hierbei nur abzuwägen, ob der erhöhte Aufwand, den die Codierung einer solchen \gls{gui} mit sich bringen würde, sinnvoll ist und wirklich eine höhere Anzahl an Kunden ansprechen würde. Weiters wäre es mit einer \gls{gui} aber auch erheblich einfacher einen Algorithmus einzubinden.\\
\\
Es erscheint dem Projektteam aufgrund der Programmiersprachenwahl am sinnvollsten, dass die User den Algorithmus in der Sprache F\# schreiben und diesen als \gls{dll} konvertieren müssen, um ihn in die Software zu integrieren. Grundsätzlich ist es dadurch in jedem Fall notwendig, dass mit der \gls{bts} zusätzlich ein Interface (zur Beschreibung von Methodennamen, die benutzt werden, usw.) und eine Beispiel-\gls{dll} bereitgestellt werden, damit die Nutzer der Software einen schnellen und einfachen Überblick bekommen, wie sie ihre \glspl{dll} aufbereiten müssen, um diese problemlos in die \gls{bts} integrieren zu können. Durch die Frage, wie die Integration eine solchen \gls{dll} nun wirklich am einfachsten für unsere zukünftigen Benutzer wäre, ergeben sich zwei Möglichkeiten zur Aufbereitung und Einbindung eines Algorithmus. Man könnte den Algorithmus einfach zur Laufzeit in die Software laden, in dem z.B. die Software ein Dateisystem-Browsing anbietet, in dem man die Algorithmus-\gls{dll} einfach auswählt, diese wird automatisch in die Software integriert und so der Algorithmus getestet. Würde die Software als Konsolenapplikation laufen, wäre dies schon etwas komplizierter für unerfahrene Nutzer, da man ein bestimmtes Kommando und den direkten Pfad zur Algorithmus-\gls{dll} selbst eintippen müsste. Eine ganz andere Möglichkeit wäre es, den Algorithmus als eigenständige Applikation bereitzustellen, auf die man über Sockets eine Verbindung aufbauen und die Rechenoperationen an sie auslagern kann. Auf diese Art und Weise wäre es ebenfalls möglich den Algorithmus zu testen, allerdings müsste das Projektteam eine viel umfangreichere Beispiel-\gls{dll} bereitstellen, in der die Eigenständigkeit der Software, sowie die Erreichbarkeit über Sockets direkt nach ihrem Start bereits vordefiniert sein müssten. Dies würde zu einem etwas erhöhten Aufwand für das Projektteam führen, wobei dies nicht das Hauptproblem dieser Variante darstellt. Denn durch die umfangreiche anfangs mit Sicherheit unübersichtliche Beispiel-\gls{dll} würden programmiertechnisch unerfahrene Benutzer schnell zurückschrecken und lieber Konkurrenzprodukte benutzen als sich in dieses Produkt aufwendig einzulesen.\\
\\
Da es sich bei Noctua um ein Projekt handelt, welches versucht, einen möglichst profitablen Handelsalgorithmus zu erstellen und die \gls{bts} eigentlich nur ein Mittel zum Vergleich der unterschiedlichen Algorithmen ist, liegt es nahe, dass im Zuge der Algorithmuserforschung alle geschriebenen Algorithmen zu jedem Testzeitpunkt gespeichert werden sollten. Außerdem wäre es erheblich von Vorteil wenn man eine Möglichkeit hätte immer alle Versionen des Algorithmus anhand ihrer von der \gls{bts} ermittelten Testergebnisse vergleichen können. Dafür muss eine Ansammlung an Daten erzeugt werden, die es ermöglicht, auch auf Rückschritte in der Performance des Algorithmus aufmerksam zu werden. Zudem sollen diese Daten zur Senkung des Aufwandes beim Tester automatisch von der \gls{bts} erstellt werden. Dafür gibt es nun zwei Möglichkeiten. Man könnte eine Datenbank aufbauen, die jeweils die getestete Version des Algorithmus zusammen mit seinen Testergebnissen (Performance, ...) in einem Datensatz speichert. Diese Lösung klingt grunsätzlich recht sinnvoll, doch bringt sie zwei Probleme mit sich. Das erste Problem ist die Speicherung des Algorithmus. Dieses könnte man allerdings über die Speicherung des Algorithmus-\gls{dll}-Files als Binary-Large-Object oder durch die Speicherung des Pfades zur Algorithmus-Datei lösen. Allerdings ist es nicht so einfach, die generellen Userwünsche zu ändern. Es ist nämlich nur ein kleiner Anteil unserer zukünftigen User gewillt, sich eine Datenbank einzurichten, nur um eine Versionierung ihrer Algorithmen zu bekommen. Deswegen hat sich das Projektteam entschieden, von der \gls{bts} einfache Dateien generieren zu lassen, die den Namen der Algorithmus-Datei und die dazu ermittelten Testergebnisse speichert. Außerdem wird im Zuge der Umsetzung von Noctua eine Dateistruktur für sowohl die Dokumentations- als auch die Algorithmus-Dateien entworfen. \\
\\
Durch diesen gesamten Analysevorgang kam das Projektteam zu dem Schluss, dass es für die zukünftige Zielgruppe des Produkts wohl am einfachsten und damit auch am sinnvollsten wäre, dieses Produkt mit einer \gls{gui} zu realisieren, da es sich bei der Zielgruppe meist zwar um börsenerfahrene Personen handelt, diese aber wahrscheinlich nicht so standfest in der Welt des .NET-Frameworks sind. Außerdem ermöglicht eine simple \gls{gui} die Einbindung eines Algorithmus mittels Dateisystem-Browsing, ohne dass der Benutzer mühsamst den Pfad selbst suchen und in die Software einfügen muss. Als Variante zur Einbindung des Algorithmus erscheint es dem Projektteam ebenfalls am sinnvollsten, den Algorithmus einfach über ein Interface mit einer ganz normalen \gls{dll} einzubinden, da es aufwendiger und wahrscheinlich auch langsamer wäre, den Algorithmus als eigenständige Software über Sockets anzusprechen. Zur Versionierung der Algorithmen wird die \gls{bts} eine Dateistruktur aus Dokumentations- und Algorithmus-Dateien anlegen, die alle Testergebnisse und Algorithmen speichert.\\
\\
Im Zuge der Überprüfung der Machbarkeit der \gls{bts} wurde auch ein Prototyp erstellt. Dieser testet, wie die Algorithmus-Datei am besten in die \gls{bts} eingebunden werden kann. Dies ist ein wenig komplizierter als es auf den ersten Blick aussieht, da der Code ja zur Laufzeit aus der \gls{dll} in die \gls{bts} eingebunden werden soll. Außerdem muss die \gls{bts} in diesem Code auch Operationen ausführen können. Dazu stellt das .NET-Framework eine ziemlich praktische Hilfestellung, durch die Unterstützung von Assemblies, zur Verfügung. Der Kern des Codes zur Integration des Algorithmus sieht so aus:

\begin{lstlisting}[label=Test der Einbindung einer DLL,caption=Test der Einbindung einer DLL]
Assembly assembly = Assembly.LoadFile(algorithmFileName);
AppDomain.CurrentDomain.Load(assembly.GetName());
Type t = assembly.GetType("Algorithm.DecisionCalculator");
            
Object[] oa = { barList, signalList };
var signal = t.GetMethod("startCalculation")
	.Invoke(null, oa);
\end{lstlisting}

Dies ermöglicht die Implementierung der geplanten Funktionalitäten der \gls{bts} und beweist, dass es machbar ist, einen Algorithmus zur Laufzeit zu integrieren.