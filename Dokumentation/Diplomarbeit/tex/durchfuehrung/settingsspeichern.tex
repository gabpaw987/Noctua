\lstset{style=sharpc}
\subsection{Persistente Sicherung der Einstellungen} \label{Einstellungen-sichern}

Die \gls{bts} bietet auf dem Settings-Tab eine Vielzahl an Einstellungen, die ein Benutzer normalerweise einmal wählt und danach nur noch selten verändert. Deshalb werden die gewählten Einstellungen bei jedem Schließen der \gls{bts} persistent in einer Anwendungskonfigurationsdatei (siehe \ref{akd} "`Anwendungskonfigurationsdateien"') gespeichert, um beim nächsten Start der Software wieder geladen werden zu können.\\
\\
Folgende Daten werden auf diese Art und Weise persistent gespeichert:

\begin{easylist}[itemize]
& \textbf{General-Settings}
	&& Pfad zum Algorithmus- und Daten-File als \inline{string}s
	&& Gewählte Berechnungsperiode als \inline{DateTime}s
& \textbf{Orders-Settings}
	&& Startkapital als \inline{string}
	&& Absolute und relative Transaktionsgebühr sowie der Price Premium Prozentsatz als \inline{string}s
	&& Slider-Werte zur Beschreibung der Order Größen sowie die Round Lot Größe als \inline{int}
& \textbf{Chart-Settings}
	&& Serialisierte \inline{StackPanel}s zum Wiederaufbau der konfigurierten Indikatoren als \inline{StringCollection}\\
\end{easylist}

Generell werden all diese Einstellungen direkt aus dem ViewModel in der Anwendungskonfigurationsdatei abgelegt. Die einzige Ausnahme davon stellen die Chart-Settings dar, da diese im ViewModel als \inline{List<StackPanel>} gespeichert werden. Anwendungskonfigurationsdateien unterstützten allerdings nur ein gewisses Spektrum an Standarddatentypen, zu denen \inline{List<StackPanel>} leider nicht gehört. Daher wurde hier auf eine \inline{StringCollection} ausgewichen.\\
\\
Dazu müssen klarerweise die einzelnen \inline{StackPanel}s in der Liste in einzelne \inline{string}s umgewandelt werden, die in der \inline{StringCollection} gespeichert werden können. Dies funktioniert durch Serialisierung jedes einzelnen Panels. Leider sind die benutzten \gls{wpf}-\gls{gui}-Elemente allerdings nicht als serialisierbar gekennzeichnet und können nur über einen speziellen \inline{XamlWriter} in ein \gls{xaml}-Format serialisiert werden, das von einem entsprechenden \inline{XamlReader} wieder ausgelesen und zurück in echte \inline{StackPanel}s umgewandelt werden kann. Weiters wird in jedem der \inline{StackPanel}s auch ein \inline{ColorPicker} aus dem Extended WPF Toolkit \cite{extended-wpf-toolkit} von Xceed benutzt. Dieser besitzt leider nicht die Möglichkeit, über einen \inline{XamlWriter} serialisiert zu werden. Dieses Problem wurde umgangen, indem der \inline{ColorPicker} vor der Serialisierung aus dem \inline{StackPanel} entfernt wird. Zur \inline{StringCollection} wird dann ein weiterer \inline{string} hinzugefügt, der die ausgewählte Farbe des \inline{ColorPicker}s speichert, damit diese beim Wiederaufbau der \inline{StackPanel}s einfach neu initialisiert und auf die entsprechend zuvor gewählte Farbe gesetzt werden kann. Anschließend wird der \inline{ColorPicker} natürlich auch wieder zum \inline{StackPanel} hinzugefügt, damit er nicht in der Anzeige der Chart-Settings fehlt. Die hierzu verwendete Methode sieht so aus:

\begin{lstlisting}[label=XML-Serialisierung der IndicatorStackPanels,caption=XML-Serialisierung der IndicatorStackPanels]
public StringCollection storeIndicatorStackPanels(List<StackPanel> stackPanels)
{
	StringCollection strings = new StringCollection();
	//Wenn StackPanels vorhanden sind, fortfahren
	if (stackPanels.Count != 0)
	{
		//Das folgende soll für jedes StackPanel durchgefuehrt
		//werden
		foreach (StackPanel sp in stackPanels)
		{
			//Wenn es ein richtig initialisiertes StackPanel
			//ist, fortfahren
			if (sp.Children[sp.Children.Count - 1]
				.GetType().IsAssignableFrom(
				(new ColorPicker()).GetType()))
			{
				//Speichern und Loeschen des
				//nicht-serialisierbaren ColorPickers
				ColorPicker cp = ((ColorPicker)sp
					.Children[sp.Children.Count - 1]);
				sp.Children.Remove(cp);
				//Serialisieren des restlichen StackPanels
				strings.Add(XamlWriter.Save(sp));
				//Speichern der Farbe des ColorPickers
				strings.Add(
					cp.SelectedColor.A + ";" + 
					cp.SelectedColor.R + ";" + 
					cp.SelectedColor.G + ";" + 
					cp.SelectedColor.B);
				//Erneutes Hinzufuegen des ColorPickers zum
				//StackPanel
				sp.Children.Add(cp);
			}
		}
	}
	return strings;
}
\end{lstlisting}

Die daraus resultierende \inline{StringCollection} kann natürlich auch in die Anwendungskonfigurationsdatei gespeichert werden. Beim Auslesen können die \inline{Stack-} \inline{Panel}s wie folgt wieder aufgebaut werden:

\begin{lstlisting}[label=XML-Deserialisierung der IndicatorStackPanels,caption=XML-Deserialisierung der IndicatorStackPanels]
public List<StackPanel> restoreIndicatorStackPanels(StringCollection strings)
{
	List<StackPanel> newList = new List<StackPanel>();

	//Durchlaufen der StringCollection
	for (int i = 0; i < strings.Count; i += 2)
	{
		//Deserialisieren des StackPanels
		newList.Add((StackPanel)XamlReader.Parse(strings[i]));

		//Neues Speichern der Listener zu jeder TextBox
		for (int j = 0; j < newList[i / 2].Children.Count;
		     j++)
		{
			if (newList[i / 2].Children[j] is
				System.Windows.Controls.TextBox)
			{
				((System.Windows.Controls.TextBox)newList[i/2]
					.Children[j]).PreviewTextInput += NumericOnly;
			}
		}

		//Erzeugen eines neuen ColorPickers und Setzen der
		//gespeicherten Farbe
		string[] argb = strings[i + 1].Split(';');
		ColorPicker cp = this.AddColorPicker();
		cp.SelectedColor = System.Windows.Media.Color.FromArgb(
			Convert.ToByte(argb[0]),
			Convert.ToByte(argb[1]),
			Convert.ToByte(argb[2]),
			Convert.ToByte(argb[3]));
		newList[i/2].Children.Add(cp);

		//Hinzufügen des Listeners für den Remove-Button
		((System.Windows.Controls.Button)newList[i/2]
			.Children[0]).Click += RemoveIndicatorButton_Click;
	}

	return newList;
}
\end{lstlisting}