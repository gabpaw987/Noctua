\lstset{language=FSharp,caption={Descriptive Caption Text},label=DescriptiveLabel}
\subsection{Implementierung eines Simple Moving Averages}
Der \gls{sma} ist der arithmetische Mittelwert über eine Menge an Preisdaten, man berechnet einen 5-Day-\gls{sma} folgendermaßen: \\\\
\begin{equation}
\frac{(P_1+P_2+P_3+P_4+P_5)}{5}
\end{equation}
\begin{lstlisting}[label=SMA in F-Sharp,caption=SMA in F-Sharp]
(* 
 * Diese Funktion soll einen SMA berechnen
 * Uebergabeparameter: 
 * n ... Laenge des SMA
 * prices ... Preise mit denen gerechnet werden soll
 *)
let sma(n:int, prices:decimal array)=
	// Fuer Menge der Preise - Laenge des SMAs 
	// kann ein Wert berechnet werden
	[|for i = n to prices.Length - 1 do 
		// yield erzeugt einen neuen
		// Wert im Array
		yield 
			// Teilen des Arrays in den  
			// gewuenschten Bereich
			Array.sub prices (i - n) n
			// Berechnen des Mittelwerts  
			// der geteilten Menge
        		|> Array.average 
	|]
	//Das Ende des Abschnitts gibt das neue Array
	//zurueck
\end{lstlisting}
\clearpage
\subsection{Implementierung eines Weighted Moving Averages}
Der \gls{wma} ist der gewichtete arithmetische Mittelwert über eine Menge an Preisdaten. Bei der Gewichtung wird darauf geachtet, dass jüngere Preisdaten  einen größeren Einfluss auf das Ergebnis des Mittelwertes haben. Man berechnet einen 5-Day-\gls{wma} folgendermaßen: \\\\
\begin{equation} 
\frac{(P_1*(5)+P_2*(5-1)+P_3*(5-2)+P_4*(5-3)+P_5*(5-4))}{(5+(5-1)+(5-2)+(5-3)+(5-4))}
\end{equation}
\begin{lstlisting}[label=WMA in F-Sharp,caption=WMA in F-Sharp]
(* 
 * Diese Funktion soll einen WMA berechnen
 * Uebergabeparameter: 
 * n ... Laenge des WMA
 * prices ... Preise mit denen gerechnet werden soll
 *)
let wma(n:int, prices:decimal array)=
            [|for i = n to prices.Length - 1 do 
            	// speichern der Referenz auf den 
            	// Zaehler
                let nom = ref 0m
                // speichern der Referenz auf den 
            	// Nenner
                let denom = ref 0m
                // Beschneiden des Arrays auf die
                // gewuenschte Laenge
                let nprices = Array.sub prices (i - n) n
		// nun muessen Zaehler und Nenner
		// gewichtet erweitert werden                
                for j in nprices.Length - 1 .. 0 do
                    // erweitern des Zaehlers
                    nom := !nom + decimal(j + 1) *
                    		nprices.[j]
		    // erweitern des Nenners
                    denom := !denom + decimal (j + 1)
                // Speichern des Quotienten in das
                // Array
                yield !nom / !denom
            |]
\end{lstlisting}
\clearpage
\subsection{Implementierung eines Triangular Moving Averages}
Der \gls{tma} ist der doppelte arithmetische Mittelwert über eine Menge an Preisdaten. Bei der Berechnung des \gls{tma} wird meist mit unterschiedlichen Längen gearbeitet.  Man berechnet einen 3-5-Day-\gls{wma} folgendermaßen: \\\\
\begin{equation} 
\frac{(\frac{P_1+P_2+P-3}{3}+\frac{P_2+P_3+P_4}{3}+\frac{P_3+P_4+P_5}{3}+\frac{P_4+P_5+P_6}{3}+\frac{P_5+P_6+P_7}{3}}{5}
\end{equation} 
\\Man erkennt bereits an der Formel, dass zur Berechnung eines \gls{tma} bedeutend mehr Preisdaten vorhanden sein müssen, als für einen \gls{sma}. 
\begin{lstlisting}[label=TMA in F-Sharp,caption=TMA in F-Sharp]
(* 
 * Diese Funktion soll einen TMA berechnen
 * Uebergabeparameter: 
 * n1 ... Laenge des ersten SMA
 * n2 ... Laenge des zweiten SMA
 * prices ... Preise mit denen gerechnet werden soll
 *)
let tma(n1:int, n2:int, prices:decimal array)=
	// Doppelter Aufruf der SMA Funktion
	sma (n2, (sma(n1, prices)))
\end{lstlisting}
\clearpage
\subsection{Implementierung eines \gls{ema}s}
Die Berechnung eines \gls{ema}, also der exponentiellen Glättung einer Datenmenge funktioniert in F-\# folgendermaßen:
\begin{lstlisting}[label=EMA in F-Sharp,caption=EMA in F-Sharp]
(* 
 * Diese Funktion soll einen EMA berechnen
 * Uebergabeparameter: 
 * n ... Laenge des EMAs
 * prices ... Preise mit denen gerechnet werden soll
 *)
let ema (n:int, prices:List<decimal>)=
	// umrechnen von n in alpha
	let alpha = (2.0m / (decimal n + 1.0m))
    // Berechnen eines SMAs als Anfangswert fuer den 
    // EMA
    let tm1 =
		prices
        |> Seq.take (n-1)
        |> Seq.average
    // Erzeugen des Outputs
    let ema : decimal array = 
    	Array.zeroCreate (List.length prices)
    // einsetzen des Anfangswertes
    ema.[n-2] <- tm1
    // Berechnen des EMAs fuer jeden Wert in der Liste
    prices
    |> List.iteri (fun i p -> 
    	match i with
    	// es koennen nur Werte errechnet werden fuer
    	// die bereits eine Glaettung davor berechnet 
    	// wurde
        | _ when i > n-2 -> ema.[i] <- 
        	alpha * p + (1m - alpha) * ema.[i-1]
        // Werte die keinen Glaettungsvorgaenger haben
        // werden ignoriert, also bleibt 0 im Array
        | _              -> ignore i)
	// loeschen des vorher eingesetzten Anfangswertes
    ema.[n-2] <- 0m
    // Rueckgabe des EMA-Arrays
    ema
\end{lstlisting}
\clearpage
\subsection{Implementierung eines Pivot Point Calculators}
Durch Pivot Points wird versucht einen Zusammenhang aus den letzten Bars für die Zukünftigen zu erzeugen. Ein Pivot Point besteht meist aus 5 bis 7 berechneten Punkten. Im folgenden Beispiel werden 5 Punkte berechnet. Davon sind 2 Support Level, 2 Resistance Level und 1 Typical Price. \\\\
Um einen Pivot Point für mehr als nur einen Bar zu berechnen, muss man den höchsten High-Wert und den niedrigsten Low-Wert der Datenmenge berechnen.
\begin{lstlisting}[label=Pivot Points in F-Sharp,caption=Pivot Points in F-Sharp]
(* 
 * Diese Funktion soll einen Pivot Point berechnen
 * Uebergabeparameter: 
 * prices ... Preise für die ein Pivot Point errechnet 
 * wird
 *)
let pivotpointcalcultor
(prices:List<(decimal,decimal,decimal,decimal)>) = 
	// errechnen des hoechsten Highs
	let h = List.max [for h in bars -> Sec h]
	// errechne des niedrigsten Lows	
	let l = List.min [for l in bars -> Third l]
	// speichern des Close	
	let c = fourth prices.[prices.Length - 1]
	// berechnen des Pivots
	let pivot = (h+l+c)/3m
	// berechnen des Support Level 1
	let sl1 = 2m*pivot - h
	// berechnen des Resistance Level 1
	let rl1 = 2m*pivot - l
	// berechnen des Support Level 2
	let sl2 = pivot - (rl1 - sl1)
	// berechnen des Resistance Level 2
	let rl2 = (pivot - sl1) + rl1
	// Rueckgabe als Tupel
	(sl2,sl1,pivot,sl1,rl2)
\end{lstlisting}
\clearpage
\subsection{Implementierung der linearen Regression}
Mit der linearen Regression kann man eine Funktion errechnen, welche allen gegebenen Punkten am Nächsten liegt. Das bedeutet, dass das Resultat der Regressionsrechnung eine Funktion lineare Funktion ist. Zur Berechnung benötigt man nur verschiedene Punkte. Die folgende Funktion berechnet nur die Steigung der Regressionsfunktion.
\begin{equation}
x = \sum_{i=0}^{n}{x_i}
\end{equation}
\begin{equation}
y = \sum_{i=0}^{n}{y_i}
\end{equation}
\begin{equation}
xy = \sum_{i=0}^{n}{y_i*i}
\end{equation}
\begin{equation}
xx = \sum_{i=0}^{n}{x^2}
\end{equation}
n = Menge der gegebenen Daten.\\
Die Variablen x, y, xy und xx werden benötigt um die Steigung der Funktion berechnen zu können. Die Steigung k wird folgendermaßen berechnet:
\begin{equation}
k = \frac{n * xy - (x*y)}{n*xx-x^2}
\end{equation}
\begin{lstlisting}[label=Regressionssteigung in F-Sharp,caption=Regressionssteigung in F-Sharp]
(* 
 * Mit dieser Funktion wird die Steigung der 
 * Regressionsfunktion berechnet
 * Uebergabeparameter: 
 * prices ... Close-Werte, welche zum Berechnen
 * verwendet werden
 *)
let regression(prices:decimal array)=
	// Berechnung von x als decimal
	let x = 
            [|0 .. prices.Length - 1|] 
            |> Array.sum 
            |> decimal
	// Berechnung von y
        let y = 
            [| for i in 0 .. prices.Length - 1 -> 
                prices.[i]|] 
            |> Array.sum
    // Berechnung von xy
        let xy = 
            [| for i in 0 .. prices.Length - 1 -> 
                prices.[i] * decimal i|] 
            |> Array.sum
	// Berechnung von xx
        let xx = 
            [| for i in 0 .. prices.Length - 1 -> 
                i*i|] 
            |> Array.sum 
            |> decimal
        (decimal prices.Length * xy - (x*y))/
        (decimal prices.Length * xx - x*x)
\end{lstlisting}
\subsection{Implementierung eines \gls{adx}}
Der \gls{adx} ist eine Indikatoren-Gruppe aus den positiven Kursbewegungen, den negativen Kursbewegungen und der True Range. Dieser Indikator errechnet die momentane Stärke des Kurses, jedoch nicht die Kursrichtung. 
\subsubsection{Positive Kursbewegungen}
Es handelt sich um eine positive Kursbewegung, wenn die Differenz aus dem momentanen High und dem letzten High größer ist als die Differenz aus dem letzten Low und dem momentanen Low. Handelt es sich um eine positive Kursbewegung, ist diese also die Differenz aus dem momentanen High und dem letzten High, es sei denn, es ist eine negative Zahl, dann wird 0 verwendet.
\begin{lstlisting}[label=Positive Kursbewegungen in F-Sharp,caption=Positive Kursbewegungen in F-Sharp]
(* 
 * Diese Funktion soll eine positive Kursbewegung 
 * berechnen
 * Uebergabeparameter: 
 * newBar ... aktuellerer Bar
 * oldBar ... letzter Bar
 * Beide Bars werden als Tupeln uebergeben
 * (Open, High, Low, Close)
 *)
let posDM 	
	(newBar:(decimal * decimal * decimal * decimal),
	oldBar:(decimal * decimal * decimal * decimal))=
	if((sec newBar - sec oldBar) > 
	   (third oldBar - third newBar)) then
	   if(sign (sec newBar - sec oldBar) = 1) then 
	   	sec newBar - sec oldBar
	0
\end{lstlisting}
\subsubsection{Negative Kursbewegungen}
Hierbei handelt es sich um das Gegenteil der positiven Kursbewegungen. Als negative Kursbewegung wird mit der Differenz aus dem letzten Low und dem heutigen Low gerechnet, außer diese ist negativ, dann wird 0 verwendet.
\begin{lstlisting}[label=Negative Kursbewegungen in F-Sharp,caption=Negative Kursbewegungen in F-Sharp]
(* 
 * Diese Funktion soll eine negative Kursbewegung 
 * berechnen
 * Uebergabeparameter: 
 * newBar ... aktuellerer Bar
 * oldBar ... letzter Bar
 * Beide Bars werden als Tupeln uebergeben
 * (Open, High, Low, Close)
 *)
let negDM 	
	(newBar:(decimal * decimal * decimal * decimal),
	oldBar:(decimal * decimal * decimal * decimal))=
	if((sec newBar - sec oldBar) < 
	   (third oldBar - third newBar)) then
	   if(sign (sec newBar - sec oldBar) = 1) then 
	   	third oldBar - third newBar
	0
\end{lstlisting}
\subsubsection{True Range}
Die True Range ist im allgemeinen der höchste Wert aus folgenden Berechnungen:
\begin{itemize}
	\item momentaner High - momentaner Low
	\item momentaner High - letzer Close
	\item letzter Close - momentaner Low
\end{itemize}
\begin{lstlisting}[label=True Range in F-Sharp,caption=True Range in F-Sharp]
(* 
 * Diese Funktion soll die True Range berechnen
 * Uebergabeparameter: 
 * newBar ... aktuellerer Bar
 * oldBar ... letzter Bar
 * Beide Bars werden als Tupeln uebergeben
 * (Open, High, Low, Close)
 *)
let trueRange 	
	(newBar:(decimal * decimal * decimal * decimal),
	oldBar:(decimal * decimal * decimal * decimal))=
	[sec newBar - third newBar; 
	sec newBar - fourth oldBar; 
	fourth oldBar - third newBar]
	|> List.max
\end{lstlisting}
\subsubsection{Directional Indicatoren}
Mit einer Menge an berechneten Kursbewegungen und der True Range lässt sich der Directional Indicator (DI) berechnen. Man berechnet immer einen positiven oder einen negativen, eine Vermischung der Kursänderungen ist nicht vorgesehen. Der DI ergibt sich aus exponentiellen Glättung der beiden:
\begin{equation}
DI=100*\frac{EMA( Kursbewegungen)}{EMA(True Range)}
\end{equation}
\subsubsection{Directional Movement Index}
Der Directional Movement Index (DX) ergibt sich aus der absoluten Differenz aus positiven und negativen DI dividiert durch die Summe der beiden:
\begin{lstlisting}[label=Directional Movement Index in F-Sharp,caption=Directional Movement Index in F-Sharp]
(* 
 * Diese Funktion soll die Directional Movement Index
 * berechnen
 * Uebergabeparameter: 
 * posDi .. Menge an berechneten positven DIs
 * negDi .. Menge an berechneten negativen DIs
 * Beide Mengen muessen gleich lang sein 
 *)
let dx(posDi:decimal array,negDi:decimal array)=
	[|for i in 0 .. posDi.Length do
		yield abs(posDi.[i] - negDi.[i])/
		      abs(posDi.[i] + negDi.[i])
	|]
\end{lstlisting}
\subsubsection{Average Directional Index}
Zur Berechnung des \gls{adx} wird eine Menge an bereits berechneten DXs für die Preisdaten benötigt. Diese werden mit 100 multipliziert und danach exponentiell geglättet und ergeben so einen \gls{adx}.
\begin{equation}
ADX=EMA(100*DX)
\end{equation}
\clearpage
\subsection{Implementieren der Bollinger Bänder}
Bollinger Bänder besteht aus 3 Teilschritten um sie zu berechnen. Der erste Schritt ist die Berechnung eines Moving Average (meist ein \gls{sma} oder ein \gls{ema}) dieser Wert ergibt das mittlere Bollinger Band. Um den dritten Schritt zu berechnen muss man zuerst die Varianz der verwendeten Werte berechnen. Der dritte Schritt ist nun das Addieren und Subtrahieren der Varianz vom Moving Average um das obere und untere Band zu berechnen.
\begin{lstlisting}[label=Bollinger Baender in F-Sharp,caption=Bollinger Baender in F-Sharp]
(* 
 * Diese Funktion soll die Bollinger Baender
 * berechnen
 * Uebergabeparameter: 
 * n .. Laenge der zu berechnenden Baendermenge
 * sigma .. Multiplikator der Varianz
 * prices .. Array der Closing Preise fuer die
 * die zu berechnenden Daten
 *)
let bollinger(n:int, sigma:decimal, prices:decimal array)=
	// Vorbereiten der Rueckgabevariable
	let result = [|for p in prices do yield (0m,0m)|]
	// Berechnen des mittleren Bollinger Bandes
	let ma = ema (n,Array.toList (prices))
	for i in n-1 .. prices.Length - 1 do
		// Berechnung der Standardabweichung
		let mutable std = 
    	[|for value in Array.sub prices (i - (n - 1)) n do 
    		yield 
    		  decimal((float)(value - ma.[i])**2.0)|]
    	|> Array.sum 
    	std <- decimal((float)(std/decimal(n-1))**0.5)                
        // Berechnen des kleineren und groesseren Bandes    
    	let higher = ma.[i] + (std * sigma)
    	let lower = ma.[i] - (std * sigma)
    	// speichern der berechneten Baender
    	result.[i] <- (higher,lower)
	result
\end{lstlisting}